{
  "comments": [
    {
      "key": {
        "uuid": "AAADEX////4\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-21T12:27:36Z",
      "side": 1,
      "message": "this is not 100% correct, you need at a minimum an atomic load-acquire to read the value of gInstance, otherwise, you don\u0027t protect the read from reordering on multi-core CPUs and you can end up in a situation where you read a value of gInstance that is !\u003d NULL, but the fields of the corresponding variable not fully initialized yet.\n\nJust use a C++ static local variable instead, it will be initialized created the first time the function is called, and this is guaranteed to be thread-safe on Android per the C++ ABI, i.e.:\n\n  // this will get called the first time ::instance() is called.\n  TilesManager*  TilesManager::create(void) {\n    TilesManager* manager \u003d new TilesManager();\n    manager-\u003ewaitForGenerater();\n    return manager;\n  }\n\n  // return the instance, lazily created on first call.\n  TilesManager* TilesManager::instance()\n  {\n     static TileManager* sIntance \u003d TilesManager::create();\n     return sInstance;\n  }\n\nNOTE: In general, static local C++ variable initialization is not thread-safe (e.g. on Windows, or when -fno-threadsafe-statics is used). But it definitely is on Android.",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADCn////g\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1004513
      },
      "writtenOn": "2012-02-21T14:15:13Z",
      "side": 1,
      "message": "True, but for portability, WebKit code is written without assuming that static local variable initialization is thread-safe. WebKit policy is to use  AtomicallyInitializedStatic in Source/JavaScriptCore/wtf/Threading.h.\n\nThe likelihood of this code being upstreamed is low, but we should probably use AtomicallyInitializedStatic for consistency.",
      "parentUuid": "AAADEX////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADEX////s\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-21T21:49:21Z",
      "side": 1,
      "message": "yeah, that totally makes sense. I didn\u0027t know about WebKit\u0027s AtomicallyInitializedStatic, but the code should use it.",
      "parentUuid": "AAADCn////g\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADGn////0\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T10:30:16Z",
      "side": 1,
      "message": "The AtomicallyInitializedStatic seems using same mechanism of the mutex. I found in the whole Source/WebCore/platform/graphics/android folder, most places are using android::Mutex::Autolock to handle thread synchronization. Maybe using Mutex is more consistent. Just my own opinion.",
      "parentUuid": "AAADCn////g\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADGn////4\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T10:30:16Z",
      "side": 1,
      "message": "Correct, there is still a potential problem to return the gInstance to a thread before gInstance-\u003ewaitForGenerator() returns. It may cause problem due to the TexturesGenerator is not ready. \nIf that\u0027s your concern, actually if we move the line \"gInstance-\u003ewaitForGenerator();\" just below the \"gInstance \u003d new TilesManager();\",  in the same locking scope, there should be no such racing condition. The double check with mutex should be thread safe in such singleton implementation and shoud be equivalent to using the AtomicallyInitializedStatic. \n\nBut there is a deadlock issue behind the problem and this was why we put the line \"gInstance-\u003ewaitForGenerator();\" out of the lock scope. \nIn this case, the second thread is created inside the call of \"new TilesManager()\". See line 115 of TilesManager.cpp: m_pixmapsGenerationThread \u003d new TexturesGenerator();\nThen in TexturesGenerator.cpp, line 125, it will call TilesManager::instance()-\u003emarkGeneratorAsReady() to notify the TitesManager thread, in which the TilesManager::instance() will be called again. If we lock all the code, it will block there to wait for the first thread return and the first thread is waiting for the notification at \"gInstance-\u003ewaitForGenerator()\". That cause deadlock, which is actually the real reason for this hang issue we found in emulator with the original code. \n\nSo, considering all, I think a better solution might be to change the TexturesGenerator code: \n1. Add a new member m_tilesManager. Since the TexturesGenerator is only created by TilesManager so should be 1:1 mapping with it. Looks like they are tightly coupled. It does not make sense for TexturesGenerator to call TilesManager-\u003einstance().  \n2. Change the constructor to TexturesGenerator::TexturesGenerator(TilesManager* tilesManager) to initialize the m_tilesManager. \n3. Replace all \"TilesManager-\u003einstance()\" with \"m_tilesManager\".\nThen we can include the \"gInstance-\u003ewaitForGenerator()\" into either the lock scope or AtomicallyInitializedStatic scope.",
      "parentUuid": "AAADEX////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADHn////Y\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-22T12:10:06Z",
      "side": 1,
      "message": "Jackie, I\u0027m afraid you don\u0027t understand SMP memory re-ordering. You _really_ need an acquire barrier when performing the gInstance read, otherwise, even with a mutex that protects all operations (let\u0027s assume waitForGenerator in inside the mutex block for simplicity), you could be in a situation where:\n\n1/ a first thread calls instance(), initializes the object, then leaves, i.e. calls mutex unlock (which provides for a \"release\" barrier that acts on the local CPU only)\n\n2/ a second thread, running on a _different_ CPU, calls instance(), it reads that the value of gInstance is not NULL so return it immediately. However, later, the thread tries to read the data in *gInstance and gets stale values.\n\nThat\u0027s because gInstance and the *gInstance fields can be on different cache lines, that do not necessarily propagate casually between CPUs. You can have a case where the cache line that contains gInstance was migrated (copied or moved) to CPU2, but not the one(s) containing *gInstance.\n\nUsing a \"load-acquire\" barrier ensures that whatever stores that happened before the mutex unlock\u0027s release barrier will be visible to other CPUs. \n\nThis kind of problem typically doesn\u0027t happen on x86 / x86_64 because their memory model essentially ensures that all atomic loads have acquire semantics, and all atomic stores have release semantics. That\u0027s not the case in general, in particular on ARM.\n\nAnother problem with your code is that, at a *minimum*, you should have declared gInstance as a volatile pointer (but even that would require an explicit barrier).\n\nAdmitedly, this is a consufing subject, but please do not trivialize memory ordering problems.",
      "parentUuid": "AAADGn////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADIX////8\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T15:26:48Z",
      "side": 1,
      "message": "David, thanks for the explaination. Indeed I trivialized it. The patch has that issue and the \"volatile\" is also a good catch.",
      "parentUuid": "AAADHn////Y\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADG3////c\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1004513
      },
      "writtenOn": "2012-02-22T15:36:51Z",
      "side": 1,
      "message": "\u003e So, considering all, I think a better solution might be ...\n\nI\u0027m not familiar with this code, but I don\u0027t see how this would work. We would need to call TilesManager::instance() in order to pass the singleton TilesManager to TexturesGenerator. But TilesManager::instance() doesn\u0027t return until waitForGenerator() is signalled by markGeneratorAsReady() within TexturesGenerator. If you work around this, you\u0027re passing a not-ready-for-use TilesManager to TexturesGenerator.\n\n\u003e To answer steve\u0027s question, the way we may use the code, it is definitely a possibility. Afaik, on master we did remove calls that ended up creating the singleton at the wrong time\n\nI think that before we consider making any such changes, we should properly understand why instance() is being called on multiple threads, and whether this is correct. What do you mean exactly by \u0027the wrong time\u0027? From Jackie\u0027s description above, it sounds like this is indeed a case where two threads make overlapping calls to instance().",
      "parentUuid": "AAADHn////Y\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADfH////8\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-03-02T05:27:40Z",
      "side": 1,
      "message": "Steve, I agree with you. That solution is more like a workaround. I think the original code may need a redesign. \nWith current design, the TitlesManager and TexturesGenerator are tightly coupled and depend on each other. Without a new design, the compromise of passing a not-ready-for-use TilesManager to TexturesGenerator seems have to be made. \nJun and me are not experts to do big changes in the android port of WebKit. Is there any action on this problem from Android webkit team?\nThanks!",
      "parentUuid": "AAADG3////c\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADjH////I\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1004513
      },
      "writtenOn": "2012-03-06T14:52:30Z",
      "side": 1,
      "message": "I think that a work-around like the one you describe isn\u0027t a good idea, as it\u0027s likely to lead to more problems.\n\nI\u0027m not an expert on this area of WebKit either - it\u0027s probably best to get input from Nicolas (nicolasroard@google.com). Do you have a bug to track this problem? That\u0027s probably a better place for discussion than this code review.",
      "parentUuid": "AAADfH////8\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEG3////8\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1011068
      },
      "writtenOn": "2012-03-20T03:59:53Z",
      "side": 1,
      "message": "Turner,\nCheck the mutex code, it looks like pthread_mutex_lock/unlock both have full memory barrier (They will call _normal_lock/unlock wihch have ANDROID_MEMBAR_FULL() called). So I suppose the mutex does have full memory barrier semantics.\n\nThe problem of this code is (My understanding. :)):  the mutex here can\u0027t make sure the the order of new operation and assignment to gInstance. So for SMP system, another CPU could see gInstance assignment while new operation is not fully finished.\n\nI suppose the fix could be easy: add a memory barrier between the new operation and gInstance assignment. But not sure whether the memory barrier operation is expoted by bionic or not. Anyway sync semantics from gcc could work.\n\nBut I am still not 100 percent sure to my understanding. Let me know if I have wrong understanding or miss something here. Thanks.",
      "parentUuid": "AAADHn////Y\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}
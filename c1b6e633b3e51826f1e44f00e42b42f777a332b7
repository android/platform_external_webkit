{
  "comments": [
    {
      "key": {
        "uuid": "AAADEX////4\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-21T12:27:36Z",
      "side": 1,
      "message": "this is not 100% correct, you need at a minimum an atomic load-acquire to read the value of gInstance, otherwise, you don\u0027t protect the read from reordering on multi-core CPUs and you can end up in a situation where you read a value of gInstance that is !\u003d NULL, but the fields of the corresponding variable not fully initialized yet.\n\nJust use a C++ static local variable instead, it will be initialized created the first time the function is called, and this is guaranteed to be thread-safe on Android per the C++ ABI, i.e.:\n\n  // this will get called the first time ::instance() is called.\n  TilesManager*  TilesManager::create(void) {\n    TilesManager* manager \u003d new TilesManager();\n    manager-\u003ewaitForGenerater();\n    return manager;\n  }\n\n  // return the instance, lazily created on first call.\n  TilesManager* TilesManager::instance()\n  {\n     static TileManager* sIntance \u003d TilesManager::create();\n     return sInstance;\n  }\n\nNOTE: In general, static local C++ variable initialization is not thread-safe (e.g. on Windows, or when -fno-threadsafe-statics is used). But it definitely is on Android.",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADCn////g\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1004513
      },
      "writtenOn": "2012-02-21T14:15:13Z",
      "side": 1,
      "message": "True, but for portability, WebKit code is written without assuming that static local variable initialization is thread-safe. WebKit policy is to use  AtomicallyInitializedStatic in Source/JavaScriptCore/wtf/Threading.h.\n\nThe likelihood of this code being upstreamed is low, but we should probably use AtomicallyInitializedStatic for consistency.",
      "parentUuid": "AAADEX////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADEX////s\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-21T21:49:21Z",
      "side": 1,
      "message": "yeah, that totally makes sense. I didn\u0027t know about WebKit\u0027s AtomicallyInitializedStatic, but the code should use it.",
      "parentUuid": "AAADCn////g\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADGn////0\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T10:30:16Z",
      "side": 1,
      "message": "The AtomicallyInitializedStatic seems using same mechanism of the mutex. I found in the whole Source/WebCore/platform/graphics/android folder, most places are using android::Mutex::Autolock to handle thread synchronization. Maybe using Mutex is more consistent. Just my own opinion.",
      "parentUuid": "AAADCn////g\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADGn////4\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T10:30:16Z",
      "side": 1,
      "message": "Correct, there is still a potential problem to return the gInstance to a thread before gInstance-\u003ewaitForGenerator() returns. It may cause problem due to the TexturesGenerator is not ready. \nIf that\u0027s your concern, actually if we move the line \"gInstance-\u003ewaitForGenerator();\" just below the \"gInstance \u003d new TilesManager();\",  in the same locking scope, there should be no such racing condition. The double check with mutex should be thread safe in such singleton implementation and shoud be equivalent to using the AtomicallyInitializedStatic. \n\nBut there is a deadlock issue behind the problem and this was why we put the line \"gInstance-\u003ewaitForGenerator();\" out of the lock scope. \nIn this case, the second thread is created inside the call of \"new TilesManager()\". See line 115 of TilesManager.cpp: m_pixmapsGenerationThread \u003d new TexturesGenerator();\nThen in TexturesGenerator.cpp, line 125, it will call TilesManager::instance()-\u003emarkGeneratorAsReady() to notify the TitesManager thread, in which the TilesManager::instance() will be called again. If we lock all the code, it will block there to wait for the first thread return and the first thread is waiting for the notification at \"gInstance-\u003ewaitForGenerator()\". That cause deadlock, which is actually the real reason for this hang issue we found in emulator with the original code. \n\nSo, considering all, I think a better solution might be to change the TexturesGenerator code: \n1. Add a new member m_tilesManager. Since the TexturesGenerator is only created by TilesManager so should be 1:1 mapping with it. Looks like they are tightly coupled. It does not make sense for TexturesGenerator to call TilesManager-\u003einstance().  \n2. Change the constructor to TexturesGenerator::TexturesGenerator(TilesManager* tilesManager) to initialize the m_tilesManager. \n3. Replace all \"TilesManager-\u003einstance()\" with \"m_tilesManager\".\nThen we can include the \"gInstance-\u003ewaitForGenerator()\" into either the lock scope or AtomicallyInitializedStatic scope.",
      "parentUuid": "AAADEX////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADHn////Y\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-22T12:10:06Z",
      "side": 1,
      "message": "Jackie, I\u0027m afraid you don\u0027t understand SMP memory re-ordering. You _really_ need an acquire barrier when performing the gInstance read, otherwise, even with a mutex that protects all operations (let\u0027s assume waitForGenerator in inside the mutex block for simplicity), you could be in a situation where:\n\n1/ a first thread calls instance(), initializes the object, then leaves, i.e. calls mutex unlock (which provides for a \"release\" barrier that acts on the local CPU only)\n\n2/ a second thread, running on a _different_ CPU, calls instance(), it reads that the value of gInstance is not NULL so return it immediately. However, later, the thread tries to read the data in *gInstance and gets stale values.\n\nThat\u0027s because gInstance and the *gInstance fields can be on different cache lines, that do not necessarily propagate casually between CPUs. You can have a case where the cache line that contains gInstance was migrated (copied or moved) to CPU2, but not the one(s) containing *gInstance.\n\nUsing a \"load-acquire\" barrier ensures that whatever stores that happened before the mutex unlock\u0027s release barrier will be visible to other CPUs. \n\nThis kind of problem typically doesn\u0027t happen on x86 / x86_64 because their memory model essentially ensures that all atomic loads have acquire semantics, and all atomic stores have release semantics. That\u0027s not the case in general, in particular on ARM.\n\nAnother problem with your code is that, at a *minimum*, you should have declared gInstance as a volatile pointer (but even that would require an explicit barrier).\n\nAdmitedly, this is a consufing subject, but please do not trivialize memory ordering problems.",
      "parentUuid": "AAADGn////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADIX////8\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T15:26:48Z",
      "side": 1,
      "message": "David, thanks for the explaination. Indeed I trivialized it. The patch has that issue and the \"volatile\" is also a good catch.",
      "parentUuid": "AAADHn////Y\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADG3////c\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1004513
      },
      "writtenOn": "2012-02-22T15:36:51Z",
      "side": 1,
      "message": "\u003e So, considering all, I think a better solution might be ...\n\nI\u0027m not familiar with this code, but I don\u0027t see how this would work. We would need to call TilesManager::instance() in order to pass the singleton TilesManager to TexturesGenerator. But TilesManager::instance() doesn\u0027t return until waitForGenerator() is signalled by markGeneratorAsReady() within TexturesGenerator. If you work around this, you\u0027re passing a not-ready-for-use TilesManager to TexturesGenerator.\n\n\u003e To answer steve\u0027s question, the way we may use the code, it is definitely a possibility. Afaik, on master we did remove calls that ended up creating the singleton at the wrong time\n\nI think that before we consider making any such changes, we should properly understand why instance() is being called on multiple threads, and whether this is correct. What do you mean exactly by \u0027the wrong time\u0027? From Jackie\u0027s description above, it sounds like this is indeed a case where two threads make overlapping calls to instance().",
      "parentUuid": "AAADHn////Y\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADfH////8\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-03-02T05:27:40Z",
      "side": 1,
      "message": "Steve, I agree with you. That solution is more like a workaround. I think the original code may need a redesign. \nWith current design, the TitlesManager and TexturesGenerator are tightly coupled and depend on each other. Without a new design, the compromise of passing a not-ready-for-use TilesManager to TexturesGenerator seems have to be made. \nJun and me are not experts to do big changes in the android port of WebKit. Is there any action on this problem from Android webkit team?\nThanks!",
      "parentUuid": "AAADG3////c\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADjH////I\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1004513
      },
      "writtenOn": "2012-03-06T14:52:30Z",
      "side": 1,
      "message": "I think that a work-around like the one you describe isn\u0027t a good idea, as it\u0027s likely to lead to more problems.\n\nI\u0027m not an expert on this area of WebKit either - it\u0027s probably best to get input from Nicolas (nicolasroard@google.com). Do you have a bug to track this problem? That\u0027s probably a better place for discussion than this code review.",
      "parentUuid": "AAADfH////8\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEG3////8\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1011068
      },
      "writtenOn": "2012-03-20T03:59:53Z",
      "side": 1,
      "message": "Turner,\nCheck the mutex code, it looks like pthread_mutex_lock/unlock both have full memory barrier (They will call _normal_lock/unlock wihch have ANDROID_MEMBAR_FULL() called). So I suppose the mutex does have full memory barrier semantics.\n\nThe problem of this code is (My understanding. :)):  the mutex here can\u0027t make sure the the order of new operation and assignment to gInstance. So for SMP system, another CPU could see gInstance assignment while new operation is not fully finished.\n\nI suppose the fix could be easy: add a memory barrier between the new operation and gInstance assignment. But not sure whether the memory barrier operation is expoted by bionic or not. Anyway sync semantics from gcc could work.\n\nBut I am still not 100 percent sure to my understanding. Let me know if I have wrong understanding or miss something here. Thanks.",
      "parentUuid": "AAADHn////Y\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAAEHX////4\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-03-20T14:14:25Z",
      "side": 1,
      "message": "Technically, you need an explicit release-store when writing to gInstance, and an explicit acquire-load when first reading it, otherwise you\u0027ll be busted, because you could read gInstance !\u003d NULL, but the TilesManager instance (initialized on another CPU) might not be completely initialized when you try to access it (on your CPU). In other words, the minimum working code should look like:\n\n  if (atomic_load_acquire(gInstance) \u003d\u003d NULL) {\n     mutex_lock()\n     if (gInstance !\u003d NULL) {\n        instance \u003d new TilesManager();\n        atomic_store_release(gInstance, instance);\n     }\n     mutex_unlock()\n  }\n  return gInstance;\n\nConsider the following case if you don\u0027t uses these operations, i.e. let\u0027s say we have this code (let\u0027s forget about the locks for simplicity):\n\n  if (gInstance \u003d\u003d NULL) {\n      gInstance \u003d new Instance();\n  }\n\nfirst, the compiler is free to translate this to something like the following:\n\n  if (gInstance \u003d\u003d NULL) {\n      gInstance \u003d malloc(sizeof(Instance));\n      Instance::Instance(gInstance);\n  }\n\nIn this scenario, if two CPUs try to access gInstance at the same time, you can be in the unfortunate case where the first CPU is initializing the instance, and has just written to gInstance with the address of a new uninitialized memory block, but hasn\u0027t called the constructor yet, and where the second CPU is performing the initial gInstance read of gInstance, and will get the value of the new block, thinking it is initialized. It may later try to access *gInstance and read incorrect data, random crashes or behaviour may follow.\n\nThe typical way to solve this is to prevent the compiler from writing to gInstance before the instance is completely initialized. Two ways to do that:\n\nThe first way is to use an explicit \"compiler barrier\", as in:\n\n  if (gInstance \u003d\u003d NULL) {\n     instance \u003d new Instance();\n     __compiler_barrier();\n     gInstance \u003d instance;\n  }\n\nThe __compiler_barrier is compiler specific. It forces the compiler to prevent any load/store operations before the barrier to be re-ordered in the generated machine code after the ones that appear after. In this specific case, it ensures that you would only write to gInstance once all the stores used to initialize the new Instance have been performed.\n\nThe second way is to define gInstance as a volatile variable. By definition, this enforces that any loads or stores to these are also compiler barriers, so the code would become:\n\n    Instance volatile*  gInstance;\n    ...\n    if (gInstance \u003d\u003d NULL) {\n        gInstance \u003d new Instance();\n    }\n\nThe code is slightly more portable, but the definition of gInstance is subtle, and it\u0027s still not good enough anyway.\n\nNote that all we\u0027ve done here is ensure that the compiler generates machine code that performs stores in the correct order. This is still *not* SMP-safe!\n\nThe reason for this is that each CPU code will re-order loads and stores more or less liberally. The compiler barrier doesn\u0027t appear in the generated code at all, and the CPU doesn\u0027t know about volatile variable accesses. We first need a special hardware-specific barrier that ensures that all stores to the new instance are performed in the correct order, so let\u0027s consider the slightly-abstract code sequence:\n\n  if (gInstance \u003d\u003d NULL) {\n    instance \u003d new Instance();\n    RELEASE_BARRIER();\n    gInstance \u003d instance;\n  }\n\nI say slightly abstract because for practical reasons, you don\u0027t want to use explicit barrier instructions in the code you write. More on this later.\n\nThe code above ensure that on the local CPU, gInstance won\u0027t be written to until all the stores corresponding to the Instance initialization has been performed.\n\nHowever, this only affects the visibility of stores on the _local_ processor. I.e. this doesn\u0027t guarantee that other CPU cores will see the sequence of cores in the same order. I.e. it still is possible for another code to read gInstance !\u003d NULL, and still read stale values when accessing *gInstance.\n\nThat\u0027s what the ACQUIRE_BARRIER() is for. To use it, the code should look like:\n\n  instance \u003d gInstance;\n  ACQUIRE_BARRIER();\n  if (instance \u003d\u003d NULL) {\n     instance \u003d new Instance();\n     RELEASE_BARRIER();\n     gInstance \u003d instance;\n  }\n\nThis is correct because the ACQUIRE_BARRIER ensures that whatever loads happen after the barrier, their data will match the stores that happened on other cores, as long as they were ordered through a RELEASE_BARRIER.\n\nIn our specific case, after ACQUIRE_BARRIER(), if instance is not NULL, we are now guaranteed that accessing any of *instance will get us values that were written before the RELEASE_BARRIER on another code. I.e. that we will never read stale values.\n\nNow, let\u0027s get back to our specific problem. The code above while correct doesn\u0027t prevent two concurrent CPUs to race for creating two new Instance objects, that\u0027s why we need a lock inside the condition to prevent this:\n\n  instance \u003d gInstance;\n  ACQUIRE_BARRIER();\n  if (instance \u003d\u003d NULL) {\n      mutex_lock(\u0026lock);\n      instance \u003d gInstance;\n      if (instance \u003d\u003d NULL) {\n         instance \u003d new Instance();\n         RELEASE_BARRIER();\n         gInstance \u003d instance;\n      }\n      mutex_unlock(\u0026lock);\n  }\n  return instance;\n\nThe lock is here to detect the very rare cases where two threads both read gInstance as NULL at the same time, and enter the condition block as the result.\n\nWe re-read gInstance to check that its value is still NULL (if not, it means we\u0027ve been stuck in the mutex_lock, waiting for another thread to create the instance, and we simply need to exit).\n\nIf the value is still NULL, we were the first to enter the mutex block, so create a new instance, and store its address in gInstance. Notice that we still need a RELEASE_BARRIER() to get sure that the ACQUIRE_BARRIER() at the start works properly.\n\nmutex_lock has an implicit acquire barrier, and mutex_unlock has an implicit release barrier. However, you cannot rely on the mutex_unlock release barrier because it *must* appear before the gInstance store.\n\nFinally, one should not use explicit barrier operations for the sake of performance and generosity. The reason is that depending on the architecture, this could be a lot more costly than necessary.\n\nOn ARM, there is only one hardware instruction that can perform a full memory barrier (i.e. both acquire + release at the same time), so you would end up using ANDROID_MEMBAR_FULL() instead of both ACQUIRE_BARRIER() and RELEASE_BARRIER() in the code above. That would be correct.\n\nOn x86, in particular, the memory model ensures that every atomic (i.e. word-aligned 32-bit) load has acquire semantics, and every atomic store has release semantics. Apart from that, there are no acquire/release hardware operations, only a \"full memory barrier\", also implemented by ANDROID_MEMBAR_FULL(). However, would you use it here instead of ACQUIRE_BARRIER() and RELEASE_BARRIER(), you would pay the price of one completely un-necessary memory barrier instruction on each function call. That would be correct but technically inefficient.\n\nThat\u0027s why you\u0027d better use *compound* atomic operations, like atomic_load_acquire() and atomic_store_release() as defined by \u003ccutils/atomic.h\u003e. These know enough about the target platform\u0027s specifics to implement the minimal-cost operation.\n\nIn other words, the final version of the correct code would be something like the following:\n\n  instance \u003d atomic_load_acquire(\u0026gInstance);\n  if (instance \u003d\u003d NULL) {\n      mutex_lock();\n      instance \u003d gInstance;\n      if (instance \u003d\u003d NULL) {\n         instance \u003d new Instance();\n         atomic_store_release(\u0026gInstance, instance);\n      }\n      mutex_unlock();\n  }\n  return instance;\n\nI hope this helps",
      "parentUuid": "AAAEG3////8\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}
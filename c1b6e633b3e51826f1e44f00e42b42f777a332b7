{
  "comments": [
    {
      "key": {
        "uuid": "AAADEX////4\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-21T12:27:36Z",
      "side": 1,
      "message": "this is not 100% correct, you need at a minimum an atomic load-acquire to read the value of gInstance, otherwise, you don\u0027t protect the read from reordering on multi-core CPUs and you can end up in a situation where you read a value of gInstance that is !\u003d NULL, but the fields of the corresponding variable not fully initialized yet.\n\nJust use a C++ static local variable instead, it will be initialized created the first time the function is called, and this is guaranteed to be thread-safe on Android per the C++ ABI, i.e.:\n\n  // this will get called the first time ::instance() is called.\n  TilesManager*  TilesManager::create(void) {\n    TilesManager* manager \u003d new TilesManager();\n    manager-\u003ewaitForGenerater();\n    return manager;\n  }\n\n  // return the instance, lazily created on first call.\n  TilesManager* TilesManager::instance()\n  {\n     static TileManager* sIntance \u003d TilesManager::create();\n     return sInstance;\n  }\n\nNOTE: In general, static local C++ variable initialization is not thread-safe (e.g. on Windows, or when -fno-threadsafe-statics is used). But it definitely is on Android.",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADCn////g\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1004513
      },
      "writtenOn": "2012-02-21T14:15:13Z",
      "side": 1,
      "message": "True, but for portability, WebKit code is written without assuming that static local variable initialization is thread-safe. WebKit policy is to use  AtomicallyInitializedStatic in Source/JavaScriptCore/wtf/Threading.h.\n\nThe likelihood of this code being upstreamed is low, but we should probably use AtomicallyInitializedStatic for consistency.",
      "parentUuid": "AAADEX////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADEX////s\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-21T21:49:21Z",
      "side": 1,
      "message": "yeah, that totally makes sense. I didn\u0027t know about WebKit\u0027s AtomicallyInitializedStatic, but the code should use it.",
      "parentUuid": "AAADCn////g\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADGn////0\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T10:30:16Z",
      "side": 1,
      "message": "The AtomicallyInitializedStatic seems using same mechanism of the mutex. I found in the whole Source/WebCore/platform/graphics/android folder, most places are using android::Mutex::Autolock to handle thread synchronization. Maybe using Mutex is more consistent. Just my own opinion.",
      "parentUuid": "AAADCn////g\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADGn////4\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T10:30:16Z",
      "side": 1,
      "message": "Correct, there is still a potential problem to return the gInstance to a thread before gInstance-\u003ewaitForGenerator() returns. It may cause problem due to the TexturesGenerator is not ready. \nIf that\u0027s your concern, actually if we move the line \"gInstance-\u003ewaitForGenerator();\" just below the \"gInstance \u003d new TilesManager();\",  in the same locking scope, there should be no such racing condition. The double check with mutex should be thread safe in such singleton implementation and shoud be equivalent to using the AtomicallyInitializedStatic. \n\nBut there is a deadlock issue behind the problem and this was why we put the line \"gInstance-\u003ewaitForGenerator();\" out of the lock scope. \nIn this case, the second thread is created inside the call of \"new TilesManager()\". See line 115 of TilesManager.cpp: m_pixmapsGenerationThread \u003d new TexturesGenerator();\nThen in TexturesGenerator.cpp, line 125, it will call TilesManager::instance()-\u003emarkGeneratorAsReady() to notify the TitesManager thread, in which the TilesManager::instance() will be called again. If we lock all the code, it will block there to wait for the first thread return and the first thread is waiting for the notification at \"gInstance-\u003ewaitForGenerator()\". That cause deadlock, which is actually the real reason for this hang issue we found in emulator with the original code. \n\nSo, considering all, I think a better solution might be to change the TexturesGenerator code: \n1. Add a new member m_tilesManager. Since the TexturesGenerator is only created by TilesManager so should be 1:1 mapping with it. Looks like they are tightly coupled. It does not make sense for TexturesGenerator to call TilesManager-\u003einstance().  \n2. Change the constructor to TexturesGenerator::TexturesGenerator(TilesManager* tilesManager) to initialize the m_tilesManager. \n3. Replace all \"TilesManager-\u003einstance()\" with \"m_tilesManager\".\nThen we can include the \"gInstance-\u003ewaitForGenerator()\" into either the lock scope or AtomicallyInitializedStatic scope.",
      "parentUuid": "AAADEX////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADHn////Y\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000411
      },
      "writtenOn": "2012-02-22T12:10:06Z",
      "side": 1,
      "message": "Jackie, I\u0027m afraid you don\u0027t understand SMP memory re-ordering. You _really_ need an acquire barrier when performing the gInstance read, otherwise, even with a mutex that protects all operations (let\u0027s assume waitForGenerator in inside the mutex block for simplicity), you could be in a situation where:\n\n1/ a first thread calls instance(), initializes the object, then leaves, i.e. calls mutex unlock (which provides for a \"release\" barrier that acts on the local CPU only)\n\n2/ a second thread, running on a _different_ CPU, calls instance(), it reads that the value of gInstance is not NULL so return it immediately. However, later, the thread tries to read the data in *gInstance and gets stale values.\n\nThat\u0027s because gInstance and the *gInstance fields can be on different cache lines, that do not necessarily propagate casually between CPUs. You can have a case where the cache line that contains gInstance was migrated (copied or moved) to CPU2, but not the one(s) containing *gInstance.\n\nUsing a \"load-acquire\" barrier ensures that whatever stores that happened before the mutex unlock\u0027s release barrier will be visible to other CPUs. \n\nThis kind of problem typically doesn\u0027t happen on x86 / x86_64 because their memory model essentially ensures that all atomic loads have acquire semantics, and all atomic stores have release semantics. That\u0027s not the case in general, in particular on ARM.\n\nAnother problem with your code is that, at a *minimum*, you should have declared gInstance as a volatile pointer (but even that would require an explicit barrier).\n\nAdmitedly, this is a consufing subject, but please do not trivialize memory ordering problems.",
      "parentUuid": "AAADGn////4\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AAADIX////8\u003d",
        "filename": "Source/WebCore/platform/graphics/android/TilesManager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 488,
      "author": {
        "id": 1000628
      },
      "writtenOn": "2012-02-22T15:26:48Z",
      "side": 1,
      "message": "David, thanks for the explaination. Indeed I trivialized it. The patch has that issue and the \"volatile\" is also a good catch.",
      "parentUuid": "AAADHn////Y\u003d",
      "revId": "c1b6e633b3e51826f1e44f00e42b42f777a332b7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}